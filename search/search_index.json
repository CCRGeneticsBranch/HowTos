{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":"<p>This page is built by following the CCBR HowTos tutorial available here.</p> <p>You will find tutorials, how-tos and documentation for khanlab relevant tasks.</p>"},{"location":"Viralsequences_download/","title":"Overview","text":"<p>GDC suggests adding viral sequences and decoys to human genome when building a reference. There are about 200 viral sequences listed here. Downloading these fasta sequences one by one can be quite tedious and prone to errors. </p>"},{"location":"Viralsequences_download/#download-steps","title":"Download steps","text":"<p>We put together a python script that will download all the viral sequences to a single fasta file.</p> <ol> <li>Copy all the lines from here and save it to a text file.(GRCh83.d1.vd1_virus_decoy.txt)</li> <li>Make sure biopython library is installed in your env. If using biowulf, you can do this in a conda env <pre><code>pip3 install biopython\n</code></pre></li> <li>Before launching the python script, please add your email id for <code>Entrez.email</code>. </li> </ol> <p>This script takes one input.</p> <pre><code>Usage: gdc_download_viral_seqs.py &lt;virus_decoys_file&gt;\n</code></pre> <p>This script filters the virus decoy file to extract the accession ids for each viral sequence. Using <code>Entrez</code> module these ids are queried to download the fasta sequences that are all saved to the output file <code>viral_sequences.fasta</code>.</p> <pre><code>#!/usr/bin/env python3\n\nimport csv\nimport sys\nfrom Bio import Entrez\nfrom Bio import SeqIO\n\nif len(sys.argv) != 2:\n    print(\"Usage: gdc_download_viral_seqs.py &lt;input_file&gt;\")\n    sys.exit(1)\n\ninput_file = sys.argv[1]\n\nwith open(input_file, 'r', newline='') as file:\n    reader = csv.reader(file, delimiter='\\t')\n    cleaned_data = [row for row in reader if any(row)]\n\naccession_ids = []\n\nif len(cleaned_data) &gt; 1:\n    for row in cleaned_data[1:]:\n        if len(row) &gt; 2:\n            value = row[2] if row[2] else (row[3] if len(row) &gt; 3 else '')\n            accession_ids.append(value)\nelse:\n    print(\"The file is empty or only contains empty lines.\")\n\n# Please add your email id here\nEntrez.email = \"vineela.gangalapudi@nih.gov\"\n\nwith open(\"viral_sequences.fasta\", \"w\") as output_file:\n    # Iterate over each accession ID\n    for accession_id in accession_ids:\n        # Fetch the sequence from NCBI\n        handle = Entrez.efetch(db=\"nucleotide\", id=accession_id, rettype=\"fasta\", retmode=\"text\")\n        fasta_sequence = handle.read()\n        handle.close()\n\n        if fasta_sequence.strip():\n            # Write the fasta sequence to the output file\n            output_file.write(fasta_sequence.strip() + \"\\n\")\n        else:\n            print(f\"Sequence not found for accession ID: {accession_id}\")\n</code></pre> <p>If you have any questions or would like to provide valuable additions to this page please email Vineela Gangalapudi.</p>"},{"location":"bedfile_formatting/","title":"Formatting bed files for khanlab exome-rnaseq pipeline.","text":"<p>The Target bed files you receive from capture kits usually arrive in different formats. Here are the steps to convert them to a pipeline accepted format. This bed file will be used to calculate Readdepth, coverage and failedexons in the pipeline.</p>"},{"location":"bedfile_formatting/#1-filter-gtf-file-to-extract-bedfile-of-exons","title":"1. Filter GTF file to extract bedfile of exons.","text":"<ol> <li>Pipeline uses gtf annotation gencodev37.</li> <li>Filter to get exons ie., by col 3.</li> <li>Convert to bed format (columns 1-3) plus format strand (replace \u00b1 with f/r), extract transcript ID, gene name, and exon number from annotations, and add header. here is an example output</li> </ol> chr start stop strand transcript_ID Genename exon_number chr1 11869 12227 f ENST00000456328.2_1 DDX11L1 1 chr1 12613 12721 f ENST00000456328.2_1 DDX11L1 2 chr1 13221 14409 f ENST00000456328.2_1 DDX11L1 3 chr1 12010 12057 f ENST00000450305.2_1 DDX11L1 1 chr1 12179 12227 f ENST00000450305.2_1 DDX11L1 2 chr1 12613 12697 f ENST00000450305.2_1 DDX11L1 3 chr1 12975 13052 f ENST00000450305.2_1 DDX11L1 4"},{"location":"bedfile_formatting/#2-downlaod-hgnc-biomart-table-to-identify-protein-coding-genes","title":"2. Downlaod HGNC Biomart table - To identify protein-coding genes","text":"<ol> <li>Download from HGNCtable with HGNC ID, status, approved symbol, approved name and Ensembl gene ID</li> <li>Filter to protein-coding transcripts (\"NM_\") and reduce to columns 8-9 (transcript_ID,RefSeq transcript ID). Here is an example output.</li> </ol> transcript_ID RefSeq transcript ID ENST00000263100.8 NM_130786.4 ENST00000373997.8 NM_014576.4 ENST00000318602.12 NM_000014.6 ENST00000299698.12 NM_144670.6 ENST00000442999.3 NM_001080438.1"},{"location":"bedfile_formatting/#3-filter-outputs-from-above-two-steps-by-merging-on-transcript-id","title":"3. Filter outputs from above two steps by merging on transcript ID","text":"<pre><code>#!/usr/bin/env python\n\nimport pandas as pd\n\ndf1 = pd.read_csv(\"Filtered_GTF_file_with_exons\",sep='\\t')\ndf1['transcript_ID'] = df1['transcript_ID'].str.split('.').str[0]\ndf1['exon_number'] = df1['exon_number'].round(decimals=0).astype(object)\n\ndf2 = pd.read_csv(\"Filtered_hgnc_biomart_table-transcript-NM\",sep='\\t')\ndf2['transcript_ID'] = df2['transcript_ID'].str.split('.').str[0]\ndf3 = pd.merge(df1,df2, on=\"transcript_ID\",how=\"inner\")\ndf3['exon_number'] = df3['exon_number'].astype(str)\ndf3['RefSeq transcript ID'] = df3['RefSeq transcript ID'].str.split('.').str[0]\ndf3['NM_ID_strand'] = df3['RefSeq transcript ID'] + \"_cds_\" + df3['strand']\n\ndf5 = df3[['chr','start','stop','Genename','exon_number','NM_ID_strand']]\ndf5['exon_number'] = df5['exon_number'].str.split('.').str[0]\ndf5.to_csv(\"gencode-exon-hgnc-biomart-table-khanlab-bed.csv\",index=False,encoding='utf-8', sep ='\\t')\n</code></pre>"},{"location":"bedfile_formatting/#4-filter-capture-kit-target-intervals-using-the-output-generated-in-step-3","title":"4. Filter Capture kit target intervals using the output generated in step 3","text":"<p>Extract columns 1-3 from the capture kit bed file.</p> <pre><code>bedtools intersect -a capture_kit_bed_file /\n                   -b gencode-exon-hgnc-biomart-table-khanlab-bed.csv /\n                   -wa -wb | cut -f1,2,3,7,8,9| bedtools sort |uniq| /\n                   -mergeBed -i - -c 4,5,6 -o distinct,collapse,collapse | /\n                   awk '{OFS=\"\\t\"}{print $1,$2,$3,$4\"___\"$5,$6}' &gt; khanlab_pipeline_accepted_bed_file.\n</code></pre> <p>This page was created through contributions from Erica Pehrsson and Vineela Gangalapudi. </p>"},{"location":"Cavatica/Overview/","title":"Accessing the data","text":"<p>To access Cavatica, log in using your NIH account and PIV card. This will display the projects you have access to on Cavatica.</p>"},{"location":"Cavatica/Overview/#downloading-small-number-of-files-with-small-sizes","title":"Downloading small number of files with small sizes:","text":"<p>The easiest way to download files from Cavatica is by following these steps:</p> <ol> <li>Log in to Cavatica using your NIH account and PIV card.</li> <li>Navigate to the project containing the files you want to download.</li> <li>Select the checkbox next to each file you want to download.</li> <li>Click the download button located at the top of the page.</li> </ol> <p></p>"},{"location":"Cavatica/Overview/#downloading-large-files","title":"Downloading large files:","text":"<p>For handling large numbers of files and files with substantial sizes such as FASTQs, VCFs, or BAM files, it's recommended to utilize the Seven Bridges python API.</p> <p>You can find instructions on how to download and use the API in the official documentation: Seven Bridges python API</p> <p>Using the API offers more efficient and flexible options for managing and downloading files from Cavatica, particularly when dealing with large datasets in nested folders.</p> <p>To access the data using API,</p> <ol> <li>Obtain the authentication token from the <code>Developer</code> tab at the top of the Cavatica page.</li> <li>Identify the API end point for Cavatica, this information can be found here.For Cavatica env API end point is https://cavatica-api.sbgenomics.com/v2</li> <li>Install the seven bridges python package in your conda env on biowulf or local machine.</li> </ol> <pre><code>#!/usr/bin/env python\nfrom sevenbridges import Api\nfrom sevenbridges.http.error_handlers import rate_limit_sleeper, maintenance_sleeper\nimport requests\nimport os\nimport sys\n\n# Initialize the Seven Bridges API client.\napi = Api(url='https://cavatica-api.sbgenomics.com/v2', token='input-your-token-here',error_handlers=[rate_limit_sleeper, maintenance_sleeper])\n\n# List all the projects you have access to.\nfor project in api.projects.query().all():\n    print (\"ID: \", project.id, \" Name:\", project.name)\n\n#View subfolders of a specific project\n#project name should be provided in this format - user/projectname example: gangalapudiv2/test\nroot_folder = api.files.query(project='Enter-your-project-name-here') \nfor folder in root_folder:\n    print(folder.id, folder.name) # Prints folder id and folder name for all the subfolders in this project\n\n#View meta data information for all the files within a folder/subfolder.\ntotal_file_size = 0\nnum_files = 0\n#using .all() to get list of all files in the subfolders.\nfolder = api.files.get(id='Provide-folder-id-here')\nfolder_subfolders = folder.list_files().all()\nfor subfolder in folder_subfolders:\n        if subfolder.type == 'folder':  # Check if it's a folder\n            print(\"Subfolder: \", subfolder.name)\n            sb = api.files.get(id=subfolder.id)\n            files = sb.list_files().all()\n            for file in files:\n                num_files += 1\n                print(\"File ID: \", file.id)\n                print(\"File Name: \", file.name)\n                print(\"File Metadata: \", file.metadata)\n        else:\n            print(f\"Skipping {subfolder.name} because it's not a folder.\")\n</code></pre> <p>Get a list of file_ids from the above step. </p> <pre><code>file_id = sys.argv[1]\nfile_obj = api.files.get(file_id)\n\noriginal_name = file_obj.name\nfile_obj.download(path=f'./pathtoyourfolder/{original_name}')\n\nprint(\"File downloaded successfully!\")\n</code></pre> <p>If you have any questions or would like to provide valuable additions to this page please email Vineela Gangalapudi.</p>"}]}